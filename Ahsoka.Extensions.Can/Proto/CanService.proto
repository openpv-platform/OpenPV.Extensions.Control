syntax = "proto3";

import "protobuf-net/protogen.proto";
import "CanConfiguration.proto";

package AhsokaCAN; // Used for CPP and Proto
option csharp_namespace = "Ahsoka.Services.Can";

message CanMessageTypes
{
    enum Ids
    {
        NONE = 0;

        OPEN_COMMUNICATION_CHANNEL = 1;
        CLOSE_COMMUNICATION_CHANNEL = 2;
        NETWORK_STATE_CHANGED = 3;
      
        SEND_CAN_MESSAGES = 4;
        SEND_RECURRING_CAN_MESSAGE = 5;
        CAN_MESSAGES_RECEIVED = 6;

        APPLY_MESSAGE_FILTER = 7;

        COPROCESSOR_IS_READY_NOTIFICATION = 8;
        COPROCESSOR_HEARTBEAT = 9;
        CAN_SERVICE_IS_READY_NOTIFICATION = 10;
    }
}

message CanApplicationConfiguration
{
    CanPortConfiguration CanPortConfiguration = 3;
}

message RecurringCanMessage
{
    uint32 can_port = 1;
    int32 transmit_interval_in_ms = 2;
    int32 timeout_before_update_in_ms = 3;
    CanMessageData message = 10;
}

message CanMessageDataCollection
{
    uint32 can_port = 1;
    repeated CanMessageData messages = 2;
}

message CanMessageData
{
    uint32 id = 1;
    uint32 dlc = 3;
    bytes data = 10 [(.protobuf_net.fieldopt).name = "Data"];
}

message CanState
{
    uint32 can_port = 1;
    uint32 current_address = 2;
    map<int32, uint32> node_addresses = 3;
}

message CanMessageResult
{
    MessageStatus status = 1;
    string message = 2;
}

enum MessageStatus
{
    success = 0;
    error = 1;
}

message DiagnosticEvent
{
    uint32 origin_canid = 1;
    uint32 fault_count = 2;
    DiagnosticEventState fault_state = 3;
    AhsokaCAN.J1939EventInfo j1939_dm = 4;
    AhsokaCAN.OBDEventInfo obd_dtc = 5;
}

enum DiagnosticEventState
{
    inactive = 0;
    active = 1;
}
